Angular installation
----------------------
1. download Nodejs
   https://nodejs.org/en/download/

2. check nodejs is installed?
   node -v

3. check if NPM is installed? (NPM-Node Package Manager)
   npm -v 

4. install angular CLI (Command Line Interface)
   npm install -g @angular/cli
		OR
   npm install -g @angular/cli@latest
		OR
   npm install -g @1ngular/cli@5

5. check if angular CLI  is installed?
   ng v
   ng help

6. create a new project
   ng new project1

7. Run the project
   in command prompt go to the project directory (ex-project1)
   ng serve (project gets deployed to server)
   
8. open your browser and open the below URL   
    http://localhost:4200
  
ng serve command launches the server, watches your files, and rebuilds the app as you make changes to those files.

To open the appilcation in browser automatically
	ng serve --open (OR) ng serve -o

to Run in other port
	ng serve --port 5000


HTML5 Scaffolding in visual studio code
----------------------------------------

1.To create HTML5 Code Snippet

!

2. html>head>title{Angular 5}

3. html>head>title{Angular 5}^body>p{Angular 5}

4.  p{Para-$}*5

5. p{Para}+p#main{para with id}+p.sty{para with class}+p[data-company="Capgemini"]{Para with attribute}

6.  table>(tr>td{td-$}*3)*3

7. div#test{this is a div with id test}


Modules
********
-Module in Angular refers to a place where you can group the components, directives, pipes, and services, which are related to the application.

-Modules are used in Angular to put logical boundaries in your application. instead of coding everything into one application, we can instead build everything into separate modules to separat
e the functionality of your application.

-In case we are developing a website, the header, footer, left, center and the right section become part of a module.


Component
*********
-Components are the most basic UI building block of an Angular app. An Angular app contains a tree of Angular components.

-Each component defines a class that contains application data and logic, and is associated with an HTML template that defines a view to be displayed.

-@Component() decorator identifies the class immediately below it as a component, and provides the template and related component-specific metadata.


Angular Cli commands
--------------------
ng g c inner --dry-run --flat -no-spec --inline-template --inline-style

g: Generate
c: Component
--flat : No Sub folders
--no-spec : No test specification file
--inline-template : No Linked Template
--inline-style : No external CSS file
--dry-run : Will display the update without execution

scaffold	usage
---------   --------
Component	ng g component my-new-component
Directive	ng g directive my-new-directive
Pipe	    ng g pipe my-new-pipe
Service	    ng g service my-new-service
Class	    ng g class my-new-class
Guard	    ng g guard my-new-guard
Interface	ng g interface my-new-interface
Enum	    ng g enum my-new-enum
Module	    ng g module my-module


Databinding
************
-automatic synchronization of data between Component and view.

1.  interpolation  	 {{ }} (1-way)   (component-->view)
2.  property Binding  [ ]  (1-way)   (component-->view)
3.  Event Binding     ( )  (1-way)   (view-->component)
4.  2-way Binding  [(ngModel)] (2-way) (component<-->view)


5.  class Binding  [class.className] = "condition"
6.  style Binding  [style.property]="value"

InterPolation: for concatenating strings;
Property: to set an element property to a non-string data value

2-way Binding:
	1. import FormsModule and add it to our Module(App.module.ts)
		a. import { FormsModule } from '@angular/forms'
		b. imports: [ BrowserModule,FormsModule]
	2. in view file use [(ngModel)]='variable'
		<input type="text" [(ngModel)]='x'>
	
CSS
****
1. inline
2. internal
3. styles in component
4. styleUrls in component
5. styles.css global


View Encapsulation
*******************
View encapsulation defines whether the template and styles defined within the component 
can affect the whole application or vice versa. 

Angular provides three encapsulation strategies:
1. Emulated (default) - styles from main HTML propagate to the component. Styles defined in this component's @Component decorator are scoped to this component only.

2. Native - styles from main HTML do not propagate to the component. Styles defined in this component's @Component decorator are scoped to this component only.

3. None - styles from the component propagate back to the main HTML and therefore are visible to all components on the page. Be careful with apps that have None and Native components in the application. All components with
 None encapsulation will have their styles duplicated in all components with Native encapsulation.

ex:- encapsulation: ViewEncapsulation.None
	 encapsulation: ViewEncapsulation.Native
	 encapsulation: ViewEncapsulation.Emulated(default)

Emulated: main--->parent Component-->child component
Native: main--->(No)parent Component-->(Yes)child component
Emulated: main<--->parent Component<-->child component
	 

Directives
***********
It is used to power up html

1. Structural Directives : (ngFor, ngIf , ngSwitch)
	Directive which changes the layout/structure of the DOM
	* is used with structural directives

2. Attribute Directives : (ngStyle,ngClass,hidden,disabled)
Directive which changes behaviour/appearance of the DOM element
[ ] is used with attribute direcives

Note : Compononent can also be considered as directive, because it powers up the html by creating Custom Element, but the directives cannot be considered as component because it does not have a View (template and templateUrl cannot be used in directives)

*ngIf vs hidden
----------------
-when *ngIf condition is false the element will neither be displayed on the page nor it will be there in the DOM.

-when [hidden] condition is true the element will not be displayed on the page but it will be there in the DOM.


ngFor predefined variables
--------------------------
index
first
last
even
odd


ngxPagination
--------------
1. install ngxpagination module
   npm install ngx-pagination --save

2. add that to our module
   import {NgxPaginationModule} from 'ngx-pagination';
   imports: [BrowserModule, NgxPaginationModule]
   
3. use in html
	<ul>
      <li *ngFor="let item of collection | paginate: { itemsPerPage: 10, currentPage: p }"> ... </li>
    </ul>               
    <pagination-controls (pageChange)="p = $event"></pagination-controls>



Angular Pipe
*************

pipe (Filter-angularJs)
	| pipe symbol

1. to Format the data (uppercase,lowercase)
2. to filter out the data (slice)

LowerCasePipe
UpperCasePipe
titleCasePipe (angular-5)
CurrencyPipe
DatePipe
DecimalPipe(number)
PercentPipe
JsonPipe 
SlicePipe
AsyncPipe (Observable)

curreny
-------                  
{{ 23 | currency}}
{{ 23 | currency : 'USD' }}
{{ 23 | currency : 'INR' }}


decimal/number
-------------
<p> {{num1 | number}} </p>
<p> {{num1 | number:'3.2-5'}} </p>
<p>{{12.638467846| number:'3.2-5'}} </p> 
o/p:- 012.63847 

<p>{{0.5 | number:'3.2-5'}} </p> 
o/p:- 000.50 

Use format '3.2-5' : 
minIntegerDigits = 3 
minFractionDigits = 2 
maxFractionDigits = 5 

Percent Pipe
-------------
{{ 2.5 | percent}}  o/p- 250%
{{ 2.5 | percent:'2.2-5'}}  o/p- 250.00%
{{0.024 | percent}}


slice pipe
-----------
slice:1:3 means return the items from the 1st to the 3rd index inclusive (indexes start at 0).
slice:2 means return the items from the 2nd index to the end of the array.
slice:2:-1 means return the items from the 2nd index to one from the end of the array.

Custom Pipe
*************
1. create a pipe file (remaining.pipe.ts)
2. create a class that class should implement PipeTransform Interface
   decorate that class with @Pipe decorator
3. override transform() method and write own logic
4. register that pipe in module(app.module.ts)
5. add to the declarations:[] in module 
6. use the pipe in HTML file
   {{"I am a student" | remaining}}
 
Pure & Impure Pipe
-------------------
-A pure pipe is only called when Angular detects a change in the value 
or the parameters passed to a pipe.(on component load only)

-An impure pipe is called for every change detection cycle
 no matter whether the value or parameters changes.(on every change)
 
-By Default every pipe we create is pure pipe.

-to make a pipe impure
  @Pipe({
		name: 'account',
		pure:false
	})
	
Use pipes in component file
--------------------------
1. import pipe class to the component	
   import { UpperCasePipe } from '@angular/common'
   
2. register that pipe service 
    providers: [UpperCasePipe]
	
3. inject that service to the component
   constructor(private upperCasePipeObj: UpperCasePipe)
   
4. use the pipe using transform()
	this.b = this.upperCasePipeObj.transform(this.a);
	

ng2searchfilter
--------------
1. install the library
   npm i ng2-search-filter

2. add the module to our module
   import { Ng2SearchPipeModule } from 'ng2-search-filter';
   imports : [Ng2SearchPipeModule]

3. use the pipe in html file\
   <h1 *ngFor='let x of names | filter : searchText'>
    {{x}}
   </h1>
	
	

Component Communication
-----------------------
parent -->  Child    propert Binding []
	angular-2   @input
	angular-5   inputs[]
	
child  -->  parent   event Binding ()
	angular-2   @output
	angular-5   outputs[]



component lifecycle hooks
--------------------------
ngOnChange - ngOnInit  - ngDoCheck - ngAfterContentInit - ngAfterContentChecked - ngAfterViewInit - ngAfterViewChecked - ngOnDestroy.

 
3 steps to use lifecycle hooks, they are:
*****************************************
1. Import Hook interfaces from '@angular/core' library
   ex:- import {onChanges} from '@angular/core'

2. Declare that component/directive and implement lifecycle hook interface
   ex: class ChildComponent implements onChanges
		{
		}

3. write the hook method and define the functionality of that method.
		ex: class ChildComponent implements onChange
		{
			ngOnChanges()
			{
				//logic
			}
		}
		
	
ex- ngOnChange() is a method from onChange interface

****************

ngOnChange()
-Invoked every time there is a change in one of the input properties of the component.

-whenever we communicate between parent and child component, the passing property from parent component 
is always received by child component with @Input decorator. When the parent changes the Input properties, 
 this hook is invoked in the child component and we can easily find out the 
details about which input properties got changed and how they got changed.

ngOnInit()
-Invoked when a component has been initialized.
-This hook is called only once after the first ngOnChanges.

ngDoCheck()
-Whenever something changes on the template of a component or inside the component then ngDoCheck() executes. 
-We can also say that it is called during every change detection run. 
-This hook is called  after ngOnInit().
-this is very similar to ngOnChanges() hook, the major difference is that
 ngOnChanges() does not detect all the changes made to the input properties. 
-It detects changes for those properties which are passed by value. However, ngDoCheck() detects changes for those  properties also which are passed by reference such as arrays.

*******
The hooks/lifecycle methods are executed in this order:

constructor()
- This is invoked when Angular creates a component or directive by calling new on the class.
- To Initialize class members,dependency Injection.
- No Business Logic should be written in constructor.

ngOnChanges()
-Invoked every time there is a change in one of the input properties of the component.

ngOnInit()
-Invoked when a component gets Initialized.
-This hook is called only once after the first ngOnChanges.
-Time Consuming Logic goes here. Ex:- API Call

ngDoCheck()
-Invoked when the change detector of the given component is invoked. 
It allows us to implement our own change detection
algorithm for the given component.
 
ngOnDestroy()
-This method will be invoked just before Angular destroys the component.
- Clean up code.  ex:- clearInterval(),clearTimeout();

ngAfterContentInit()
Invoked after Angular performs any content projection into the components view 

ngAfterContentChecked()
Invoked each time the content of the given component has been checked by the change detection mechanism of Angular.

ngAfterViewInit()
Invoked when the component’s view has been fully initialized.

ngAfterViewChecked()
Invoked each time the view of the given component has been checked by the change detection mechanism of Angular.

N.p-ngDoCheck and ngOnChanges should not be implemented together on the same component


Angular Change Detection Strategies
-----------------------------------
@ViewChild
-----------
-Want to get access to a child component or a DOM element from a parent component class? It’s easy to do with the ViewChild decorator. ViewChild returns the first element that matches a given component, or template reference selector

A @ViewChild decorator means, search inside this components template, it’s view, for this child component.

The parameter we pass as the first argument to @ViewChild is the type of the component we want to search for, if it finds more than one it will just give us the first one it finds.
-to inject a reference to a component
-The value of this injected member variable is not immediately available at component construction time!

Angular will fill in this property automatically, but only later in the component lifecycle, after the view initialization is completed.
-A component might need references to the multiple elements that it contains inside its template, in order to mediate their interaction.
-we can obtain references to those template elements and have them injected into the AppComponent class by querying the template: that's what @ViewChild is for.

	
	
Observables
***********
-observable is an array whose items arrive asynchronously over time. 
-Observables help you manage asynchronous data, such as data coming from a backend service.
-Observables are used within Angular itself, including Angular’s event system and its http client service. 
-To use observables, Angular uses a third-party library called Reactive Extensions (RxJS).
-observables are lazy collections of multiple values over time.
-An observable can deliver multiple values of any type-literals, messages, or events
used for event handling, asynchronous programming, and handling multiple values


Promise vs Observables
***********************
-Promise return all the data at once, where as observable return multiple values over time.
-promise is not lazy. observable is lazy(observable is not called until we subscribe)
-promise is not cancellable, where as observable can be cancelled using unsubscribe()
-observable has different operators (map,filter,reduce,retry)
 
Promises:
-----------
1. return a single value
2. not cancellable
3. more readable code with try/catch and async/await
4. no Operator support (map,filter,reduce)


Observables:
-----------
1. multiple values over time
2. cancellable
3. support map, filter, reduce and similar operators
4. use Reactive Extensions (RxJS)
5. an array whose items arrive asynchronously over time



Web optimization and Build
---------------------------
-Angular offers two ways to compile your application:

1. Just-in-Time (JIT), which compiles our application in the browser at runtime.

2. Ahead-of-Time (AOT), which compiles your application at build time.

Note:- JIT compilation is the default when we run the ng build (build only) or ng serve (build and serve locally) CLI commands

JIT
===== 
-browser requires angular compiler and downloads at runtime
-Compile TypeScript just in time(runtime) for executing it.
-Compiled in the browser.
-Each file compiled separately.
-No need to build after changing your code and before reloading the browser page.
-Suitable for local development.

AOT
====
-browser doesnt require angular compiler because 
it will be compiled in the build itself
-Compile TypeScript during build phase.
-Compiled by the machine itself, via the command line (Faster).
-All code compiled together, inlining HTML/CSS in the scripts.
-No need to deploy the compiler (Half of Angular size).
-More secure, original source not disclosed.
-Suitable for production builds.
   
files
-----
Main.js : it contains all our application code. 
		  (components,pipes,services,directives)
		
runtime.js: it contains all the web-pack configuration details.

polyfills.js: it contains the code which make sure our application
			  runs in all browsers.
			 
styles.js: it contains all the application styles.

vendor.js: it contains all the 3rd party library deatils.
			(bootstrap,d3chart)
			
web-pack:
---------
-Webpack is an open-source JavaScript module bundler.
- Its main purpose is to bundle JavaScript files for usage in a browser.
-it is capable of transforming, bundling, or packaging any resource or asset.

> ng serve:
It Builds and serves the application. rebuilding on file changes.
	1. It won't create dist folder;
	2. generated files will be  stored in the internal memory
	3. It wont perform web optimization(Minifying the Scripts)
	4. we cann't run in external server.

> ng build:
compiles an application and stores the generated files in dist folder.
	1. It creates a dist folder
	2. generated files will be  stored in dist(that can be moved)
	3. It wont perform web optimization(Minifying the Scripts)
	4. generated dist folder can be placed in any server and application can be run. (tomcat weblogic)


2. AOT (Ahead-Of-Time)Compilation : 
Application will be pre compiled 

The browser doesnt require angular compiler because 
it will be compiled in the build itself.

> ng serve --aot (It wont create dist folder but it will be stored in the internal memory) - 
      It wont perform web optimization(Minifying the Scripts)

> ng build --aot (It creates a dist folder)-It wont perform web optimization(Minifying the Scripts)

> ng build --prod (It creates a dist folder)-It performs web optimization(Minifying the Scripts)


inline.bundle.js
-----------------
This is a webpack loader. A tiny file with Webpack utilities that are needed when loading other files.

vendor.bundle.js
----------------
It includes the Angular libraries with little or no modification. This is to speed up the build process. 

main.bundle.js
---------------
Your own code, and anything else you imported etc


Run Commands using Package.json
--------------------------------

> npm run start ( "start": "ng serve --port 3000")

> npm run build ( "build": "ng build --prod")


Angular Services
******************
Services
---------  
- share logic/data across components
- code Reuseability
- Lazily instantiated
	(Angular only instantiates a service when a component depends on it.)
- Singletons
	(Each component dependent on a service gets a reference to the single instance generated by the service factory.only one instance of the service gets created through out the application)

-create a service using angular CLI
 ng generate service myService
		OR
 ng g s myService


steps to create and use service
--------------------------------
1. create a service 
	a. write a class with set of methods and properties.
	b. decorate that class with @injectable decorator
	
2. register that service in module
	a. import the service to module
	b. add it to providers array 
	   providers:[MathService]
	 
3. use a service in component
   a. import service to component file
   b. create a referrence variable for that service
   c. using the referrence variale make use of methos and properties
   
   
httpClient Service
--------------------
1. make httpClientModule available to our module
	a. import httpClientModule from '@angular/common/http' to our module
	b. add it to imports:[]

2. make httpClient Service available to Service/component
   a. import httpClient service from '@angular/common/http' in component
   b. create a referrence variable of httpClient
   c. using that referrence variable call httpClient methods(GET,POST,PUT,DELETE)
   

HTTP Methods
------------
GET - Retrieve data from DB
	  search
	  
POST - to send data to server  ( sign up ) (create a new record in DB)
	   to fetch data securly    (send params in body not in URL)

PUT - update data ( update password/update mobile number )

DELETE -  delete a record from DB (Delete naukri account)



Create REST API with json-server
---------------------------------
1.  Install npm-server 
	npm install -g json-server
2. create a json file	
    db.json
3. start json server
   json-server --watch db.json
   
http://localhost:3000/employees
   
GET    /employees
GET    /employees/{id}
POST   /employees
PUT    /employees/{id}
PATCH  /employees/{id}
DELETE /employees/{id}


Form
---------
Classes:
ng-pristine : No user interaction occured/not yet modified
ng-dirty : User interaction occured/modified
ng-valid : It meets all the validation
ng-invalid : One of the Validation is not meeting
ng-touched: already touched
ng-untouched: not yet touched

Template Driven Forms Features
---------------------------
-Easy to use
-Suitable for simple scenarios and fails for complex scenarios
-Similar to AngularJS(1.x)
-Two way data binding(using [(NgModel)] syntax)
-Minimal component code
-Automatic track of the form and its data(handled by Angular)
-FormsModule

-Unit testing is a challenge(testing validation logic)
-limited capabilities to implement dynamic aspects like 
variable number of fields, repetitive fields, etc.

Model driven forms/Reactive Forms Features
--------------------------------------
-More flexible, but needs a lot of practice
-Handles any complex scenarios
-No data binding is done (immutable data model preferred by most developers)
-More component code and less HTML markup
-Adding elements dynamically
-Easier unit testing(testing validation logic)
-Form fields are created programmatically by using FormGroup or FormBuilder class
-Supports creation of forms with dynamic structure at runtime
-Uses ReactiveFormModule

Template Driven Form
---------------------
1. import FormsModule to our module

2. view File-
   a. use ngForm directive with form template reference variable
      <form name="myForm" #user="ngForm" ></form>
   b. Use ngModel directive with input field reference variable
   <input name="name" #name="ngModel" [(ngModel)]="user.name" required pattern="[a-zA-Z]+" />
   
  c. use ngModelGroup directive to group multiple fields
	 <fieldset ngModelGroup="address">...</fieldset>
	 

Model driven form
------------------
1. import ReactiveFormsModule to our module add to imports:[]
	a. import { ReactiveFormsModule } from '@angular/forms';
	b. imports:[BrowserModule,ReactiveFormsModule]  
	
2. view - 
	a. use formGroup with form
		<form [formGroup]="registerForm">
	b. use formControlName with every form field
		<input type="text" formControlName="firstname">
	c. use formGroupName to group multiple form fields.
	    <fieldset formGroupName="address">...</fieldset>

3. Component
	a. create FormGroup class Object to group fields
		new FormGroup({    })
	b. create FormGroup class object for each form fieldssss

	
	
Routing
********
Every time a link is clicked or the browser URL changes, Angular router makes sure your application reacts accordingly.

To accomplish that, Angular router performs the following 7 steps in order:

PRIGRAM
--------
Parse: it parses the browser URL the user wants to navigate to
Redirect: it applies a URL redirect (if one is defined)
Identify: it identifies which router state corresponds to the URL
Guard: it runs the guards that are defined in the router state
Resolve: it resolves the required data for the router state
Activate: it activates the Angular components to display the page
Manage: it manages navigation and repeats the process when a new URL is requested

Terminology
------------
router service: the global Angular router service in our application
router configuration: definition of all possible router states our application can be in
router state: a state of the router at some point in time, expressed as a tree of activated route snapshots
activated route snapshot: provides access to the URL, parameters and data for a router state node
guard: script that runs when a route is loaded, activated or deactivated
resolver: script that fetches data before the requested page is activated
router outlet: location in the DOM where Angular router can place activated components
URL segments: parts of the URL that are divided by slashes

routing
-----------------
1. index.html	
    <base href="/">
	
2. app.module.ts	
   a. import { RouterModule } from '@angular/router';
	  import {appRoutes} from './routerconfig'
   b. imports: [
        BrowserModule, RouterModule
    ]
	
3. create components
	ng g c html
	ng g c css
	ng g c javascript
	ng g c notfound
	
4. create a file routerconfig.ts to configure all the routes.
   export const appRoutes: Routes = [

    {
        path: 'home',
        component: HomeComponent
    },
    {
        path: 'aboutUs',
        component: AboutusComponent
    }]

5. app.component.html
   
   <div style="text-align: center">
	  <nav>
		<a routerLink="home">Home</a> <br><br>
		<a routerLink="aboutUs">About Us</a> <br><br>
		<a routerLink="career">Career</a>
	  </nav>
	  <hr>
	  <router-outlet></router-outlet>
	</div>


Navigate from one route to another
-----------------------------------
constructor(private routerObj : Router) { }

  takeMeToHtml() {
    this.routerObj.navigate(['/html'])
  }
  
  
Angular Build process
----------------------
JIT - Just in time
	angular compiler gets downloaded at run time.  
	  compiles the application in the browser at run time
	 
	  
AOT - Ahead Of Time
     compiles the application at build time itself.
     compiler gets ready at build time itself. better
	 browser doesnt havve to download angular compiler at run time.
 

5 files:
-------
main.js -   all our application code (components,pipes,services)
 
pollyfill.js - makes sure our application runs in all the browsers

runtime.js - it contains all the webpack configuration details

vendor.js - all third party libraries ( bootstrap,jquery,ngxserach,ngxpagination)

styls.js -  (all the css files)



ng serve:
---------
-Builds and serves your app, rebuilding on file changes.

-it doesnt create a dist folder

-generated files are stored in the internal memory

-it doesnt perform web optimization (minifying)

-we cannot run the application in extenal server (only can be run in angular provided server)


ng build:
--------
 -Compiles an Angular app into an output directory named dist/ at the given output path. 
 -Must be executed from within a workspace directory.
 -creates a dist folder, generated files will be stored inside dist
 -it doesnt perform web optimization (minifying)





  
Unit Testing Using Jasmine and karma
-------------------------------------
-jasmine is framework for testing javascript code.

- karma is a test runner

AngularJs vs angular
-------------------
1. Javascript				1. Typescript
2. MVC						2. Component
3. CLI-No					3. CLI
4. filters					4. Pipes
5. Controller				5. Controller-No
6. $scope,$rootscope		6. NO
7. Unit testing 			7. Unit testing - better
8. mobile devices-No		8. mobile devices-yes

Angular-4
------------
-a lot of improvements made to reduce the size of the AOT (Ahead-of-time) compiler generated code.

-In Angular 2 only TypeScript 1.8 version was supported, whereas, in Angular 4, it supports TypeScript 2.1 and TypeScript 2.2.

-The Animation features are separated from @angular/core package and added to @angular/animations.

-along with *ngif, we can use else block as well.

-Supports for email validator

-titlepipe

Angular-5
----------
- Build Optimizer
- HttpClient instead of Http
- ngFor improvements
- supports TypeScript 2.3 



lazy loading
-------------
-In lazy loading our application does not load everything at once. It loads only those things what the user expects to see when the app first loads. It helps to decrease the startup time.

-Lazy loading enables to load only the module user is interacting and keep the rest modules to be loaded at run time on demand.



Dependency injection 
---------------------
Dependency injection (DI), is an important application design pattern. Angular has its own DI framework, which is typically used in the design of Angular applications to increase their efficiency and modularity. ... In Angular, the DI framework provides declared dependencies to a class when that class is instantiated.
		